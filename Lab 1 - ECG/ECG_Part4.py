# Code generated by ChatGTP; edited by Copilot, and Thomas Murimboh; and comments by Thomas Murimboh
# May 01, 2024

# -----SETTING THE STAGE-----
# In this part, we will use scipy.signal.findpeaks() to count the number of heartbeats.
# This will allow us to calculate the number of beats per minute (BPM)

#-----LINKS TO DOCUMENTATION-----
# scipy.signal.findpeaks() --> https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks.html#scipy.signal.find_peaks

import nidaqmx                                                       # this is how we will communicate with the NI device                               
from nidaqmx.constants import AcquisitionType, TerminalConfiguration # import some constants from nidaqmx (try print(AcquisitionType) to see what it is)
import numpy as np                                                   # numpy is used for various math things. Rename as 'np' for easier reference later                                        
import matplotlib.pyplot as plt                                      # for plotting data (a very widely used library)                                   
import pandas as pd                                                  # for saving data to .CSV files easily (among other things)                                                    
from scipy.signal import butter, filtfilt, find_peaks                # these premade functions in the scipy library will help filter our noisy data, and find peaks in our signal    

# Parameters
device = "Dev2"                           # Your NI device name
channel = "ai0"                           # Analog input channel
sample_rate = 1000                        # Samples per second (Hz)
total_time = 10                            # Total acquisition time in seconds
buffer_size = total_time * sample_rate    # How many samples to collect

# A Butterworth bandpass filter set to keep frequencies of  0.5â€“40 Hz
def butter_bandpass(lowcut, highcut, fs, order=4):  # give this function space to input four arguments. Lowcut and highcut are the max and min frequencies to keep, fs is the sampling frequency, and the order is how steep our cutoff is
    nyquist = 0.5 * fs                              # This is based off of cool math that is beyond the scope of this course https: // en.wikipedia.org/wiki/Nyquist_frequency. fs is the sampling frequency.
    low = lowcut / nyquist                          # more math things (max frequency to keep)
    high = highcut / nyquist                        # more math things (min frequency to keep)
    b, a = butter(order, [low, high], btype='band') # apply the filter! It gives us some coefficients                   
    return b, a                                     # return two coefficients for later use

# use filtfilt (a digital filter) to filter our voltage signal
def apply_bandpass_filter(data, lowcut=0.5, highcut=40.0, fs=1000.0, order=4): # give this function a space to input data; and set cutoff frequencies, sampling rate and order (cutoff steepness)                                                                     
    b, a = butter_bandpass(lowcut, highcut, fs, order)                         # call the butter_bandpass function, input values for the four arguments in ITS definition, and save the output. These values come from the variables set in THIS function's definition
    y = filtfilt(b, a, data)                                                   # b and a are used as coefficients for the filter                                                                                                                                      
    return y                                                                   # return the filtered data

# Data acquisition and processing
task=nidaqmx.Task()
task.ai_channels.add_ai_voltage_chan(f"{device}/{channel}",
                                    terminal_config=TerminalConfiguration.DIFF) # adds an analog input assigned to {device} and {channel}
task.timing.cfg_samp_clk_timing(rate=sample_rate,
                                sample_mode=AcquisitionType.FINITE,
                                samps_per_chan=buffer_size) # for configuring when to take samples based on the hardware's internal sample clock
# Acquire data
data = task.read(number_of_samples_per_channel=buffer_size) # get a number of readings from the NI device equal to buffer_size                                                 
task.stop()                                                 # stops the nidaqmx task                                                                                           
task.close()                                                # clears all modifications made to the nidaqmx task                                                                

times = np.linspace(0,total_time, buffer_size)              # creates a number of evenly spaced times from 0 to total_time equal to buffer_size                                
data = np.array(data)                                       # creates a numpy array                                                                                            
times = np.array(times)                                     # these arrays work much fatser than regular arrays in python because numpy is partially built with a C/C++ backend

# Apply bandpass filter
filtered_data = apply_bandpass_filter(data, lowcut=0.5, highcut=40.0, fs=sample_rate, order=4) # use the apply_bandpass_filter function. We pass in our collected data (which is different than the placeholder in the function definition),                   
#                                                                                              override the fs value from the function definition with sample_rate, and keep the other argument values the same as the function definition

df=pd.DataFrame(filtered_data, index=times, columns=['voltage'])                               # create a dataframe (like a python spreadsheet). The index is the time axis, and the data is the voltage values.                        
# df.to_csv(r'F:\python\ECG Stuff\ECG_data.csv', index=True, header=True)                        # Save the data to a CSV file (the r at the beginning indicates that this is a file path)


# Peak detection
threshold = np.mean(filtered_data) + 0.5 * np.std(filtered_data)                              # this threshold value will be different depending of the data it receives. I think the formula used to calculate it is somewhat arbitrary                          
min_distance = int(sample_rate * 0.5)                                                         # the minimum distance between detected peaks. It currently works for heart rates up to about 150 bpm. Try changing the distance between peaks and see what happens!
peaks, _ = find_peaks(filtered_data, height=threshold, distance=min_distance, prominence=0.1) # use scipy's function and pass the correct arguments. It returns two arrays, one for each peak's position in the data array (stored in peaks) and one for the
#                                                                                             peak's properties (stored in _) which we don't really care about. The height controls how high the peak must be compared to a value of 0, and the  prominence value controls how high the
#                                                                                             peak must be compared to the average value of the data.

# Calculate heart rate
duration_minutes = total_time / 60.0       # calculate how long the program ran in minutes                          
heart_rate = len(peaks) / duration_minutes # calculate heart rate in bpm by taking the total number of peaks/time in minutes
print(f"\n\n=== Acquisition Complete ===") 
print(f"Detected {len(peaks)} beats in {total_time:.2f} seconds.")
print(f"Estimated Heart Rate: {heart_rate:.2f} beats per minute (bpm)\n\n")

# Plot the final graph
fig, ax = plt.subplots(figsize=(10,5)) # create a figure with one set of axes to put data and set thw figure size to 10" wide by 5" tall
ax.plot(times, filtered_data, linewidth=2, label="Filtered ECG Signal")   # plot signal data with a label                                                                      
ax.plot(times[peaks], filtered_data[peaks], 'rx', label="Detected Peaks") # plots points at times and heights indexed by [peaks]. rx stands for red x (marker colour and shape)
ax.set_xlabel('Time (seconds)')                                               # label the x axis                                                                                   
ax.set_ylabel('Voltage (V)')                                                  # label the y axis                                                                                   
ax.set_title('ECG Signal with Detected Peaks')                                # title the graph
ax.legend(loc="best")                                                     # 1 is top right, 2 is top left, 3 is bottom right, 4 is bottom left. You can also spell out locations (eg. "center left"). https: // matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html
ax.grid(True)                                                             # show a grid background      
fig.tight_layout()
plt.show()                                                                 # show the final plot


# Now it's your turn! go to https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html and try to figure out how to save your plot!
# Hint: just focus on the first argument of the function and use r before your string to indicate a file path