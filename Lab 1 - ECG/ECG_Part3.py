# Code generated by ChatGTP and edited by Copilot

# -----SETTING THE STAGE-----
# In this part, we will setup a bandpass filter (to remove signal noise). 
# For the most part, scipy.signal.butter() and scipy.signal.filtfilt() do the hard work and we just have to send the 
# functions a signal (our voltage values) and some other patrameters

#-----LINKS TO DOCUMENTATION-----
#scipy.signal.butter() -->https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html#scipy.signal.butter
#scipy.signal.filtfilt() --> https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html#scipy.signal.filtfilt

# -----LINKS TO COOL SCIENCE STUFF-----
# Nquist frequency --> https://en.wikipedia.org/wiki/Nyquist_frequency


import nidaqmx                                                       # this is how we will communicate with the NI device                               
from nidaqmx.constants import AcquisitionType, TerminalConfiguration # import some constants from nidaqmx (try print(AcquisitionType) to see what it is)
import numpy as np                                                   # numpy is used for various math things. Rename as 'np' for easier reference later                                        
import matplotlib.pyplot as plt                                      # for plotting data (a very widely used library)                                   
import pandas as pd                                                  # for saving data to .CSV files easily (among other things)                                                    
from scipy.signal import butter, filtfilt                            # these premade functions in the scipy library will help filter our noisy data     


# Parameters
device = "Dev1"                           # Your NI device name
channel = "ai0"                           # Analog input channel
sample_rate = 1000                        # Samples per second (Hz)
total_time = 5                            # Total acquisition time in seconds
buffer_size = total_time * sample_rate    # How many samples to collect

# A Butterworth bandpass filter set to keep frequencies of  0.5â€“40 Hz
def butter_bandpass(lowcut, highcut, fs, order=4):  # give this function space to input four arguments. Lowcut and highcut are the max and min frequencies to keep, fs is the sampling frequency, and the order is how steep our cutoff is
    nyquist = 0.5 * fs                              # This is based off of cool math that is beyond the scope of this course https: // en.wikipedia.org/wiki/Nyquist_frequency. fs is the sampling frequency.
    low = lowcut / nyquist                          # more math things (max frequency to keep)
    high = highcut / nyquist                        # more math things (min frequency to keep)
    b, a = butter(order, [low, high], btype='band') # apply the filter! It gives us some coefficients                   
    return b, a                                     # return two coefficients for later use

# use filtfilt (a digital filter) to filter our voltage signal
def apply_bandpass_filter(data, lowcut=0.5, highcut=40.0, fs=1000.0, order=4): # give this function a space to input data; and set cutoff frequencies, sampling rate and order (cutoff steepness)                                            
    b, a = butter_bandpass(lowcut, highcut, fs, order) # call the butter_bandpass function, input values for the four arguments in ITS definition, and save the output. These values come from the variables set in THIS function's definition
    y = filtfilt(b, a, data)                           # b and a are used as coefficients for the filter                                                                                                                                      
    return y                                           # return the filtered data

# Data acquisition and processing
task=nidaqmx.Task()
task.ai_channels.add_ai_voltage_chan(f"{device}/{channel}",
                                    terminal_config=TerminalConfiguration.RSE) # adds an analog input assigned to {device} and {channel}
task.timing.cfg_samp_clk_timing(rate=sample_rate,
                                sample_mode=AcquisitionType.FINITE,
                                samps_per_chan=buffer_size) # for configuring when to take samples based on the hardware's internal sample clock
# Acquire data
data = task.read(number_of_samples_per_channel=buffer_size) # get a number of readings from the NI device equal to buffer_size                                                 
task.stop()                                                 # stops the nidaqmx task                                                                                           
task.close()                                                # clears all modifications made to the nidaqmx task                                                                

times = np.linspace(0,total_time, buffer_size)              # creates a number of evenly spaced times from 0 to total_time equal to buffer_size                                
data = np.array(data)                                       # creates a numpy array                                                                                            
times = np.array(times)                                     # these arrays work much fatser than regular arrays in python because numpy is partially built with a C/C++ backend


df=pd.DataFrame(filtered_data, index=times, columns=['voltage'])                               # The index is the time axis, and the data is the voltage values.                        
df.to_csv(r'F:\python\ECG Stuff\ECG_data.csv', index=True, header=True)                        # Save the data to a CSV file (the r at the beginning indicates that this is a file path)

# Apply bandpass filter
filtered_data = apply_bandpass_filter(data, lowcut=0.5, highcut=40.0, fs=sample_rate, order=4)
df=pd.DataFrame(filtered_data, index=times, columns=['voltage'])        # The index is the time axis, and the data is the voltage values.                        
df.to_csv(r'F:\python\ECG Stuff\ECG_data.csv', index=True, header=True) # Save the data to a CSV file (the r at the beginning indicates that this is a file path)

# Plot the final graph
plt.figure(figsize=(10, 5))                                     # create a figure and set the figure size to 10" by 5"                                                                           
plt.plot(times, data, linewidth=2, label="Filtered ECG Signal") # plot signal data with a label                                                                                                  
plt.xlabel('Time (seconds)')                                    # label the x axis                                                                                                               
plt.ylabel('Voltage (V)')                                       # label the y axis                                                                                                               
plt.title('ECG Signal')                                         # title the graph                                                                                                                
plt.legend(loc="best")                                          # 1 is top right, 2 is top left, 3 is bottom right, 4 is bottom left. You can also spell out locations (eg. "center left"). https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html
plt.grid(True)                                                  # show a grid background                                                                                                         
plt.show()                                                      # show the final plot
